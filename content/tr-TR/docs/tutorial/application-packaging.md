# Uygulama Paketleme

Windows'ta uzun yol adları etrafındaki [issues](https://github.com/joyent/node/issues/6960) azaltmak için `require`’ı biraz hızlandırın ve kaynak kodunuzu muayene işleminden gizleyin, uygulamanızı, kaynak kodunuzda ufak değişiklikler yaparak bir [asar](https://github.com/electron/asar) arşivine paketlemeyi seçebilirsiniz.

## `asar` Arşivi Oluşturuluyor

Bir [asar](https://github.com/electron/asar) arşivi, dosyaları birleştiren basit bir tar benzeri formatta tek bir dosyaya dönüştürür. Electron, bütün dosyaları paketten çıkarmadan rastgele dosyaları okuyabilir.

Uygulamanızı bir `asar` arşivine paketlemeye ilişkin adımlar:

### 1. Asar Yardımcı Programını Kurun

```sh
$ npm kurma -g asar
```

### 2. Paket `asar pack`

```sh
$ asar pack your-app app.asar
```

## Arşivleri `asar` kullanma

Electron'da iki API seti vardır: Node.js ve Web tarafından sağlanan buton API'leri Chromium tarafından sağlanan API'ler. Her iki API, `asar` arşivlerinden dosyaları okumayı desteklemektedir.

### Node API

Electron'da özel yamalarla, `fs.readFile` ve `require` gerektirir. ` asar` arşivlerini sanal dizinler olarak ve içindeki dosyalar normal Dosya sistemindeki dosyalardır.

Örneğin, bir `example.asar` archive under `/path/to`:

```sh
$ asar list /path/to/example.asar
/app.js
/file.txt
/dir/module.js
/static/index.html
/static/main.css
/static/jquery.min.js
```

`asar` Arşivindeki bir dosyayı okuyun:

```javascript
const fs = require('fs')
fs.readFileSync('/path/to/example.asar/file.txt')
```

Arşivin kök dizinindeki tüm dosyaları listeleyin:

```javascript
const fs = require('fs')
fs.readdirSync('/path/to/example.asar')
```

Arşivdeki bir modülü kullanın:

```javascript
gerektirir('/path/to/example.asar/dir/module.js')
```

`BrowserWindow` ile `asar` arşivinde bir web sayfası da gösterebilirsiniz:

```javascript
const {BrowserWindow} = require('electron')
let win = new BrowserWindow({width: 800, height: 600})
win.loadURL('file:///path/to/example.asar/static/index.html')
```

### Web API

Bir web sayfasında, arşivdeki dosyalar `file:` protokolü ile istenebilir. Buton API'sı gibi, `asar` arşivleri de dizin olarak değerlendirilir.

Örneğin, bir dosyayı almak için `$.get`:

```html
<script>
let $ = require('./jquery.min.js')
$.get('file:///path/to/example.asar/file.txt', (data) => {
  console.log(data)
})
</script>
```

### `asar` Arşivini Normal Dosya Olarak İşleme

Bazı durumlarda, `asar` arşivinin doğrulanması gibi, `asar ` arşivinin bir dosya olarak içeriğini okumamız lazım. Bu amaçla `original-fs` module which provides original `fs` APIs without `asar` dahili desteği kullanabilirsiniz:

```javascript
const originalFs = require('original-fs')
originalFs.readFileSync('/path/to/example.asar')
```

You can also set `process.noAsar` to `true` to disable the support for `asar` in the `fs` module:

```javascript
const fs = require('fs')
process.noAsar = true
fs.readFileSync('/path/to/example.asar')
```

## Node API'nin Limitleri

Even though we tried hard to make `asar` archives in the Node API work like directories as much as possible, there are still limitations due to the low-level nature of the Node API.

### Arşiv salt okunur

Arşivler değiştirilemez, bu nedenle dosyaları değiştirebilen tüm Buton API'leri `asar` arşivleriyle çalışın.

### Çalışma dizini arşivdeki dizinlere ayarlanamıyor

`asar` arşivleri dizin olarak değerlendirilse de, gerçek dizinleri, çalışma dizini olarak asla ayarlayamazsınız dizinler `asar` arşivlerinde. Bazı API'ların `cwd` seçeneği olarak geçirilmesi hatalara neden olur.

### Bazı API'lerde Ekstra Paketten Çıkarma

Çoğu `fs` API'si bir dosyayı okuyabilir veya paketten çıkarmadan bir dosya bilgisini `asar` arşivlerinden alabilir ancak gerçek dosya yolunu temel alınan sistem çağrılarına geçirmeye dayanan bazı API'ler için, Electron gerekli dosyayı geçici bir dosyaya çıkaracaktır ve geçici dosyanın yolunu API'lara çalışması için iletirler. Bu, bu API'ler için biraz yük getirir.

Ek paketten çıkarmayı gerektiren API'ler şunlardır:

* `child_process.execFile`
* `child_process.execFileSync`
* `fs.open`
* `fs.openSync`
* `process.dlopen` - Used by `require` on native modules

### Sahte Stat Bilgileri `fs.stat`

The `Stats` object returned by `fs.stat` and its friends on files in `asar` archives is generated by guessing, because those files do not exist on the filesystem. So you should not trust the `Stats` object except for getting file size and checking file type.

### Executing Binaries Inside `asar` Archive

There are Node APIs that can execute binaries like `child_process.exec`, `child_process.spawn` and `child_process.execFile`, but only `execFile` is supported to execute binaries inside `asar` archive.

This is because `exec` and `spawn` accept `command` instead of `file` as input, and `command`s are executed under shell. There is no reliable way to determine whether a command uses a file in asar archive, and even if we do, we can not be sure whether we can replace the path in command without side effects.

## Adding Unpacked Files in `asar` Archive

As stated above, some Node APIs will unpack the file to filesystem when calling, apart from the performance issues, it could also lead to false alerts of virus scanners.

To work around this, you can unpack some files creating archives by using the `--unpack` option, an example of excluding shared libraries of native modules is:

```sh
$ asar pack app app.asar --unpack *.node
```

After running the command, apart from the `app.asar`, there is also an `app.asar.unpacked` folder generated which contains the unpacked files, you should copy it together with `app.asar` when shipping it to users.