# इलेक्ट्रॉन वर्ज़निंग

> हमारी वर्ज़निंग नीति और उसके कार्यान्वयन पर एक विस्तृत लेख |

संस्करण 2.0.0 से, इलेक्ट्रॉन [semver](#semver) का प्रयोग करता है | निम्नलिखित कमांड इलेक्ट्रॉन की सबसे नवीनतम स्थिर बनावट इनस्टॉल करती है:

```sh
npm install --save-dev electron
```

एक मौज़ूदा प्रोजेक्ट को नवीनतम स्थिर संस्करण तक अपडेट करने के लिए:

```sh
npm install --save-dev electron@latest
```

## संस्करण 1.x

इलेक्ट्रॉन संस्करण *< 2.0*, [semver](http://semver.org) स्पेक के अनुरूप नहीं थें | मुख्य संस्करण एंड-यूजर ऐपीआई परिवर्तनों के अनुकूल हैं | लघु संस्करण क्रोमियम की मुख्य रिलीज़ के अनुरूप हैं | पैच संस्करण नयी सुविधाओं और बग फिक्सेस के अनुकूल हैं | हालाँकि यह उन डेवलपर्स के लिए आरामदायक हैं जो सुविधायें जोड़ते हैं, पर क्लाइंट-फेसिंग एप्लीकेशनस के डेवलपर्स के लिए यह मुश्किलें कड़ी करते हैं | स्लैक, टीम्स, स्काइप, वीएस कोड, एटम, और डेस्कटॉप जैसी मुख्य एप्प्स के क्युऐ परिक्षण चरण काफी लम्बे हो सकते हैं और स्थिरता बेहद आवश्यक निश्कर्ष है | त्रुटियों को सही करने के दौरान नयी सुविधायें को अपनाने में बहुत बड़ा खतरा है |

1.x रणनीति का एक उदाहरण:

![](../images/versioning-sketch-0.png)

`1.8.1` से निर्मित एप्प बिना `1.8.2` की सुविधा अपनायें `1.8.3` का बग फिक्स इस्तेमाल नहीं कर सकती, या फिर वह फिक्स को बैकपोर्ट करें और फिर एक नयी रिलीज़ पंक्ति को बनाये रखें |

## संस्करण 2.0 और उससे आगे

हमारी 1.x रणनीति से कई सारे परिवर्तन हुए हैं, जो नीचे दिए गये हैं | हर परिवर्तन का उद्देश्य डेवलपर्स/मैन्तैनेर्स और एप्प डेवलपर्स की ज़रूरतों और प्राथमिकताओं को संतुष्ट करना है |

1. semver का कड़ाई से इस्तेमाल
2. semver-अनुरूप `-beta` टैग से परिचय
3. [पारंपरिक कमिट संदेशों](https://conventionalcommits.org/) से परिचय
4. स्पष्ट रूप से परिभाषित स्थिरीकरण शाखायें
5. `master` शाखा बिना संस्करण के है; केवल स्थिरता शाखाओं के पास संस्करण जानकारी उपलब्ध है

गिट शाखा, एनपीएम टैगिंग, डेवलपर्स को कैसी अपेक्षा रखनी चाहिये, और कैसे कोई बैकपोर्ट परिवर्तन करें, इन सब चीजों पर हम विस्तार से बात करेंगे |

# semver

2.0 संस्करण से, इलेक्ट्रॉन semver का पालन करेगा।

नीचे एक टेबल दिया गया है जो परिवर्तनों के प्रकारों को उनके अनुरूप semver की श्रेणी (जैसे कि मुख्य, लघु, पैच आदि) से मैप करता है |

* **मुख्य संस्करण वृद्धि** 
    * क्रोमियम संस्करण अपडेटस
    * नोड.जेएस मुख्य संस्करण अपडेटस
    * इलेक्ट्रॉन ब्रेकिंग ऐपीआई परिवर्तन
* **लघु संस्करण वृद्धि** 
    * नोड.जेएस लघु संस्करण अपडेटस
    * इलेक्ट्रॉन नॉन-ब्रेकिंग ऐपीआई परिवर्तन
* **पैच संस्करण वृद्धि** 
    * नोड.जेएस पैच संस्करण अपडेटस
    * त्रुटी-सुधार क्रोमियम पैच
    * इलेक्ट्रॉन बग-फिक्सेस

ध्यान दें कि ज्यादातर क्रोमियम अपडेटस ब्रेकिंग माने जायेंगे | सुधार जिन्हें बैकपोर्ट किया जा सके, उन्हीं में से कुछ के पैच के तौर पर चुने जाने की संभावना है |

# स्थिरीकरण शाखायें

स्थिरीकरण शाखायें वे शाखायें हैं जो मास्टर के साथ-साथ चलती हैं, और केवल उन ख़ास कमिटस को चुनती हैं जो सुरक्षा या स्थिरता से सम्बंधित हैं | ये शाखायें कभी भी मास्टर में विलय नहीं की जाती |

![](../images/versioning-sketch-1.png)

स्थिरीकरण शाखायें हमेशा **मुख्य** या **लघु** संस्करण पंक्ति होती हैं, और इनका नाम निन्मलिखित टेम्पलेट `$MAJOR-$MINOR-x` e.g. `2-0-x` के अनुरूप होता है |

हम विभिन्न स्थिरीकरण शाखाओं को एक साथ मौज़ूद होने की सुविधा प्रदान करते हैं, और हमारा उद्देश्य है कि हर समय कम से कम 2 शाखाओं को एक साथ समर्थित करें, और आवश्यकता अनुसार सुरक्षा सुधार बैकपोर्ट करते रहें | ![](../images/versioning-sketch-2.png)

पुरानी पंक्तियाँ गिटहब द्वारा समर्थित नहीं होगी, पर दुसरे समहू स्वामित्व प्राप्त कर सकते हैं और खुद ही स्थिरता और सुरक्षा सुधार बैकपोर्ट कर सकते हैं | हम ऐसा न करने की सलाह देते हैं, पर यह भी समझते हैं की इससे एप्प डेवलपर्स का काम काफी आसान हो जाता है |

# बीटा रिलीज़ और बग फिक्सेस

डेवलपर्स जानना चाहते हैं कि कौन सी रिलीजिज़ इस्तेमाल करने के लिए*सुरक्षित* हैं | हानिरहित दिखने वाली सुविधायें भी जटिल एप्लीकेशनस में त्रुटियाँ ला सकती हैं | पर साथ ही, एक स्थायी संस्करण पर टिके रहना काफी ख़तरनाक हो सकता है क्योंकि आप सुरक्षा पैच और बग फिक्सेस को नज़रअंदाज़ कर रहे हैं जो आप के इस्तेमाल में आने वाले संस्करण के बाद जारी किये गये हों | हमारा लक्ष्य, `package.json` में निम्नलिखित मानक semver सीमाओं को अनुमति देने का है:

* `2.0.0` में स्थिरता या सुरक्षा सम्बंधित फिक्सेस लाने के लिए ही `~2.0.0` का इस्तेमाल करें |
* `^2.0.0` का इस्तेमाल नॉन-ब्रेकिंग *काफी हद तक स्थिर* सुविधाओं और साथ ही सुरक्षा और बग फिक्सेस को अनुमति देने के लिए करें |

दूसरी बिंदु में जो आवश्यक बात है वह यह कि `^` को इस्तेमाल करने वाली एप्प्स भी कुछ हद तक स्थिरता की अपेक्षा रख सकें | इसे पूरा करने के लिए, semver एक *pre-release identifier* को अनुमति प्रदान करता है ताकि वह यह पता लगा सके कि दिया गया संस्करण इस्तेमाल करने के लिए *सुरक्षित* या *स्थिर* है या नहीं |

आप कुछ भी चुनें, पर आपको समय-समय पर `package.json` का संस्करण बढ़ाना ही होगा क्योंकि ब्रेकिंग चेंजेस क्रोमियम जीवन का एक सत्य है |

इसकी प्रक्रिया निम्नलिखित है:

1. सभी मुख्य और लघु रिलीज़िस पंक्तियाँ `-beta.N` से शुरू होंगी जहाँ `N >= 1` होगा | इस समय पर, सुविधा सेट **लॉक्ड** होगा | वह रिलीज़ पंक्ति और ज्यादा सुविधाओं को शामिल करने की अनुमति नहीं देती, और केवल सुरक्षा और स्थिरता पर केन्द्रित होती है | उदाहरण: `2.0.0-beta.1` |
2. बग फिक्सेस, रिग्रेशन फिक्सेस और सुरक्षा पैच को अनुमति मिल सकती है | ऐसा करने पर, `N` को बढ़ा कर एक नया बीटा रिलीज़ किया जाता है | उदाहरण: `2.0.0-beta.2`
3. अगर एक दी गयी बीटा रिलीज़ *सामान्यतः* स्थिर मानी जाती है, तो उसे एक स्थिर बिल्ड के रूप में दोबारा से रिलीज़ किया जायेगा, और केवल संस्करण जानकारी को बदला जायेगा | उदाहरण: `2.0.0` |
4. अगर भविष्य में एक स्थिर रिलीज़ में बग फिक्सेस या सुरक्षा पैच शामिल करने हो, तो उन्हें शामिल करना होगा और उसकी अनुसार *पैच* संस्करण को बढ़ाना होगा उदाहरण: `2.0.1` |

हर मुख्य और लघु बढ़त पर, आप को कुछ ऐसा दिखेगा:

```text
2.0.0-beta.1
2.0.0-beta.2
2.0.0-beta.3
2.0.0
2.0.1
2.0.2
```

तस्वीरों में एक जीवनकाल का उदाहरण:

* एक नयी रिलीज़ ब्रांच निर्मित की जाती है जिसमे नवीनतम सुविधाओं का सेट शामिल होता है | इसे `2.0.0-beta.1` के रूप में प्रकाशित किया जाता है | ![](../images/versioning-sketch-3.png)
* मास्टर में एक बग फिक्स शामिल होता है, जिसे रिलीज़ शाखा में पैक-पोर्ट किया जा सकता है | पैच लगाया जाता है, और नयी बीटा `2.0.0-beta.2` के रूप में प्रकाशित होती है | ![](../images/versioning-sketch-4.png)
* बीटा को *सामान्यतः स्थिर* मान जाता है और उसे दोबारा नॉन-बीटा के रूप में `2.0.0` के नीचे प्रकाशित किया जाता है | ![](../images/versioning-sketch-5.png)
* बाद में, एक शून्य-दिवस एक्सप्लॉइट पायी जाती है और मास्टर में एक फिक्स शामिल किया जाता है | हम फिक्स को `2-0-x` पंक्ति में पैक-पोर्ट करते हैं और `2.0.1` को प्रकाशित करते हैं | ![](../images/versioning-sketch-6.png)

कुछ उदाहरण कि कैसे semver सीमायें नयी रिलीज़िस चुनती हैं:

![](../images/versioning-sketch-7.png)

# नामौज़ूद सुविधायें अल्फा, और नाईटली

हमारी रणनीति की भी कुछ खामियाँ है, पर हम समझते हैं कि फिलहाल उनसे कोई फर्क नहीं पड़ता | ख़ासकर यह कि मास्टर में नयी सुविधायें शामिल करने में कुछ समय लग सकता है, इससे पहले कि वह एक स्थिर रिलीज़ पंक्ति तक पहुंचे | अगर आप नयी सुविधाओं को तुरंत ही इस्तेमाल करना चाहते हैं, तो आप को खुद ही इलेक्ट्रॉन का निर्माण करना होगा |

भविष्य को ध्यान में रखते हुए, हम निम्नलिखित में से एक या दोनों को ला सकते हैं:

* मास्टर की नाईटली बिल्डस ऑफ; आपको नयी सुविधाओं का तुरंत परिक्षण करने और फीडबैक देने की अनुमति प्रदान करेगी
* alpha releases that have looser stability constraints to betas; for example it would be allowable to admit new features while a stability channel is in *alpha*

# Feature Flags

Feature flags are a common practice in Chromium, and are well-established in the web-development ecosystem. In the context of Electron, a feature flag or **soft branch** must have the following properties:

* is is enabled/disabled either at runtime, or build-time; we do not support the concept of a request-scoped feature flag
* it completely segments new and old code paths; refactoring old code to support a new feature *violates* the feature-flag contract
* feature flags are eventually removed after the soft-branch is merged

We reconcile flagged code with our versioning strategy as follows:

1. we do not consider iterating on feature-flagged code in a stability branch; even judicious use of feature flags is not without risk
2. you may break API contracts in feature-flagged code without bumping the major version. Flagged code does not adhere to semver

# Semantic Commits

We seek to increase clarity at all levels of the update and releases process. Starting with `2.0.0` we will require pull requests adhere to the [Conventional Commits](https://conventionalcommits.org/) spec, which can be summarized as follows:

* Commits that would result in a semver **major** bump must start with `BREAKING CHANGE:`.
* Commits that would result in a semver **minor** bump must start with `feat:`.
* Commits that would result in a semver **patch** bump must start with `fix:`.

* We allow squashing of commits, provided that the squashed message adheres the the above message format.

* It is acceptable for some commits in a pull request to not include a semantic prefix, as long as a later commit in the same pull request contains a meaningful encompassing semantic message.

# Versionless `master`

* The `master` branch will always contain `0.0.0-dev` in its `package.json`
* Release branches are never merged back to master
* Release branches *do* contain the correct version in their `package.json`