# 應用程式打包

為了避開 Windows 處理長路徑名稱的[問題](https://github.com/joyent/node/issues/6960)，並稍微加快 `require` 效能，防止原始程式碼一眼就被看到。只需要一點點修改，就能把你的應用程式打包進 [asar](https://github.com/electron/asar) 封存檔。

## 產生 `asar` 封存檔

[asar](https://github.com/electron/asar)壓縮檔類似 tar 格式，將多個檔案串接成單一檔案。 Electron 可以讀取當中的任意檔案，而不用整包解開。

將應用程式打包進 `asar` 封存檔的步驟:

### 1. 安裝 asar 工具

```sh
$ npm install -g asar
```

### 2. 透過 `asar pack` 打包

```sh
$ asar pack your-app app.asar
```

## 使用 `asar` 封存檔

Electron 中有兩大塊 API: 由 Node.js 提供的 Node API，以及 Chromium 提供的 Web API。兩種 API 都能由 `asar` 封存檔中讀取檔案。

### Node API

透過 Electron 的特別修改，`fs. readFile` 和 `require` 等 Node API 會將 `asar` 封存檔視為虛擬目錄，裡面的檔案就像是檔案系統中的一般檔案。

舉例來說，假設在 `/path/to` 目錄下有一個 `example.asar` 封存檔:

```sh
$ asar list /path/to/example.asar
/app.js
/file.txt
/dir/module.js
/static/index.html
/static/main.css
/static/jquery.min.js
```

由 `asar` 封存檔中讀取檔案:

```javascript
const fs = require('fs')
fs.readFileSync('/path/to/example.asar/file.txt')
```

列出封存檔根目錄下的所有檔案:

```javascript
const fs = require('fs')
fs.readdirSync('/path/to/example.asar')
```

使用封存檔中的模組:

```javascript
require('/path/to/example.asar/dir/module.js')
```

你也可以在 `BrowserWindow` 中顯示 `asar` 封存檔中的網頁:

```javascript
const {BrowserWindow} = require('electron')
let win = new BrowserWindow({width: 800, height: 600})
win.loadURL('file:///path/to/example.asar/static/index.html')
```

### Web API

In a web page, files in an archive can be requested with the `file:` protocol. Like the Node API, `asar` archives are treated as directories.

For example, to get a file with `$.get`:

```html
<script>
let $ = require('./jquery.min.js')
$.get('file:///path/to/example.asar/file.txt', (data) => {
  console.log(data)
})
</script>
```

### 將 `asar` 封存檔視為一般檔案

For some cases like verifying the `asar` archive's checksum, we need to read the content of an `asar` archive as a file. For this purpose you can use the built-in `original-fs` module which provides original `fs` APIs without `asar` support:

```javascript
const originalFs = require('original-fs')
originalFs.readFileSync('/path/to/example.asar')
```

You can also set `process.noAsar` to `true` to disable the support for `asar` in the `fs` module:

```javascript
const fs = require('fs')
process.noAsar = true
fs.readFileSync('/path/to/example.asar')
```

## Node API 的限制

Even though we tried hard to make `asar` archives in the Node API work like directories as much as possible, there are still limitations due to the low-level nature of the Node API.

### 封存檔是唯讀的

The archives can not be modified so all Node APIs that can modify files will not work with `asar` archives.

### 不能將封存檔中的目錄設為工作目錄

Though `asar` archives are treated as directories, there are no actual directories in the filesystem, so you can never set the working directory to directories in `asar` archives. Passing them as the `cwd` option of some APIs will also cause errors.

### 針對某些 API 額外解開

Most `fs` APIs can read a file or get a file's information from `asar` archives without unpacking, but for some APIs that rely on passing the real file path to underlying system calls, Electron will extract the needed file into a temporary file and pass the path of the temporary file to the APIs to make them work. This adds a little overhead for those APIs.

APIs that requires extra unpacking are:

* `child_process.execFile`
* `child_process.execFileSync`
* `fs.open`
* `fs.openSync`
* `process.dlopen` - 用來 `require` 原生模組

### `fs.stat` 的假 Stat 資訊

The `Stats` object returned by `fs.stat` and its friends on files in `asar` archives is generated by guessing, because those files do not exist on the filesystem. So you should not trust the `Stats` object except for getting file size and checking file type.

### 執行 `asar` 封存檔中的二進位檔

There are Node APIs that can execute binaries like `child_process.exec`, `child_process.spawn` and `child_process.execFile`, but only `execFile` is supported to execute binaries inside `asar` archive.

This is because `exec` and `spawn` accept `command` instead of `file` as input, and `command`s are executed under shell. There is no reliable way to determine whether a command uses a file in asar archive, and even if we do, we can not be sure whether we can replace the path in command without side effects.

## 將無法封存的檔案與 `asar` 封存檔整合

As stated above, some Node APIs will unpack the file to filesystem when calling, apart from the performance issues, it could also lead to false alerts of virus scanners.

To work around this, you can unpack some files creating archives by using the `--unpack` option, an example of excluding shared libraries of native modules is:

```sh
$ asar pack app app.asar --unpack *.node
```

After running the command, apart from the `app.asar`, there is also an `app.asar.unpacked` folder generated which contains the unpacked files, you should copy it together with `app.asar` when shipping it to users.